defmodule Clr.Air.Type do
  require Pegasus
  require Clr.Air

  Clr.Air.import(
    Clr.Air.Base,
    ~w[int identifier enum_literal squoted space dot comma cs lparen rparen langle rangle lbrack rbrack lbrace rbrace dstring notnewline]a
  )

  Clr.Air.import(Clr.Air.Lvalue, ~w[lvalue basic_lvalue]a)

  Pegasus.parser_from_string(
    """
    # full type things
    typelist <- lparen ((noalias space)? type (cs (noalias space)? type)*)? rparen
    type <- errorunion_only / ((errorunion bang)? (comptime space)? '?'? general_types)

    general_types <- enum_literal_type / fn_type / ptr_type / array_type / struct_type / comptime_call_type / lvalue

    # special types
    enum_literal_type <- '@Type(.enum_literal)'

    # comptime call types.  Note that these are not "function calls", but rather a type generated by
    # comptime function call where the function has returned a type.  Only a limited set of inputs
    # are allowed.

    comptime_call_type <- basic_lvalue comptime_call_params
    comptime_call_params <- lparen (comptime_call_param (comma comptime_call_param)*)? rparen
    comptime_call_param <- int / type

    ptr_type <- (one_ptr / many_ptr / slice_ptr / sentinel_many_ptr / sentinel_slice_ptr) (alignment space)? (const space)? type
    array_type <- '[' int ']' type

    ## single token words
    const <- 'const'
    comptime <- 'comptime'
    align <- 'align'
    noalias <- 'noalias'

    one_ptr <- '*'
    many_ptr <- '[*]'
    slice_ptr <- '[]'
    sentinel_many_ptr <- '[*:' sentinel ']'
    sentinel_slice_ptr <- '[:' sentinel ']'
    alignment <- align lparen int rparen

    sentinel <- 'null' / '0'

    fn_type <- ('*' const space)? 'fn' space typelist (space callconv)? space type
    callconv <- 'callconv' lparen (inline / c / naked) rparen
    inline <- '.@"inline"'
    c <- '.c'
    naked <- '.naked'

    struct_type <- 'struct' space lbrace space type (cs type)* space rbrace

    errorunion_only <- errorunion
    errorunion <- 'anyerror' / error errorlist
    errorlist <- lbrace identifier (comma identifier)* rbrace
    error <- 'error'
    bang <- '!'
    """,
    literal: [export: true, parser: true],
    int_literal: [export: true, post_traverse: :int_literal],
    fn_literal: [export: true, post_traverse: :fn_literal],
    other_literal: [export: true, post_traverse: :other_literal],
    map_literal: [export: true, post_traverse: :map_literal],
    # literal toolbox
    as: [post_traverse: :as],
    ptrcast: [post_traverse: :ptrcast],
    type: [export: true, parser: true, post_traverse: :type],
    function_call_type: [post_traverse: :function_call_type],
    array_type: [post_traverse: :array_type],
    ptr_type: [post_traverse: :ptr_type],
    fn_type: [export: true, post_traverse: :fn_type],
    const: [token: :const],
    function: [token: :function],
    callconv: [post_traverse: :callconv],
    sentinel: [collect: true, post_traverse: :sentinel],
    enum_literal_type: [token: :enum_literal],
    inline: [token: :inline],
    c: [token: :c],
    naked: [token: :naked],
    function: [token: :function],
    comptime: [token: :comptime],
    align: [token: :align],
    map_value: [collect: true],
    struct_type: [post_traverse: :struct_type],
    stringliteral: [post_traverse: :stringliteral],
    error: [token: :error],
    errorunion_only: [post_traverse: :errorunion_only],
    errorlist: [post_traverse: :errorlist],
    structptr: [post_traverse: :structptr],
    bang: [ignore: true],
    noalias: [token: :noalias],
    sizeof: [post_traverse: :sizeof],
    alignof: [post_traverse: :alignof],
    builtinfunction: [post_traverse: :builtinfunction],
    comptime_call_type: [export: true, post_traverse: :comptime_call_type],
    comptime_call_params: [post_traverse: :comptime_call_params]
  )

  # TYPE post-traversals

  defp type(rest, [type], context, _line, _bytes), do: {rest, [type], context}

  defp type(rest, [type, "anyerror"], context, _line, _bytes) do
    {rest, [{:errorable, :any, type}], context}
  end

  defp type(rest, [type, errorlist, :error], context, _line, _bytes) do
    {rest, [{:errorable, errorlist, type}], context}
  end

  defp type(rest, [type, :comptime], context, _line, _bytes),
    do: {rest, [comptime: type], context}

  defp type(rest, [{:ptr, kind, type}, "?"], context, _line, _bytes) do
    {rest, [{:ptr, kind, type, optional: true}], context}
  end

  defp type(rest, [{:ptr, kind, type, opts}, "?"], context, _line, _bytes) do
    {rest, [{:ptr, kind, type, Keyword.put(opts, :optional, true)}], context}
  end

  defp type(rest, [type, "?"], context, _line, _bytes) do
    {rest, [{:optional, type}], context}
  end

  defp array_type(rest, [type, "]", int, "["], context, _line, _bytes) do
    {rest, [{:array, int, type}], context}
  end

  defp fn_type(rest, [return_type | args_rest], context, _line, _bytes) do
    {arg_types, opts} = fn_info(args_rest, [])
    {rest, [{:fn, arg_types, return_type, opts}], context}
  end

  defp fn_info([{:callconv, _} = callconv | rest], opts), do: fn_info(rest, [callconv | opts])
  defp fn_info(rest, opts), do: {fn_args(rest), opts}

  defp fn_args(args) do
    case Enum.reverse(args) do
      ["fn" | args] -> collect_noalias(args, [])
      ["*", :const, "fn" | args] -> collect_noalias(args, [])
    end
  end

  defp collect_noalias([:noalias, type | rest], so_far) do
    collect_noalias(rest, [{:noalias, type} | so_far])
  end

  defp collect_noalias([head | rest], so_far), do: collect_noalias(rest, [head | so_far])

  defp collect_noalias([], so_far), do: Enum.reverse(so_far)

  defp ptr_type(rest, args, context, _, _) do
    {rest, [ptrfor(args)], context}
  end

  defp ptrfor([type, "*"]), do: {:ptr, :one, type}
  defp ptrfor([type, "[*]"]), do: {:ptr, :many, type}
  defp ptrfor([type, "[]"]), do: {:ptr, :slice, type}

  defp ptrfor([type, "]", sentinel, "[*:"]) do
    {:ptr, :many, type, sentinel: sentinel}
  end

  defp ptrfor([type, "]", sentinel, "[:"]) do
    {:ptr, :slice, type, sentinel: sentinel}
  end

  defp ptrfor([type, alignment, :align | rest]) do
    case ptrfor([type | rest]) do
      {:ptr, kind, name} -> {:ptr, kind, name, alignment: alignment}
      {:ptr, kind, name, opts} -> {:ptr, kind, name, Keyword.put(opts, :alignment, alignment)}
    end
  end

  defp ptrfor([type, :const | qualifiers]) do
    case ptrfor([type | qualifiers]) do
      {:ptr, kind, name} -> {:ptr, kind, name, const: true}
      {:ptr, kind, name, opts} -> {:ptr, kind, name, Keyword.put(opts, :const, true)}
    end
  end

  defp sentinel(rest, ["null"], context, _line, _bytes) do
    {rest, [:null], context}
  end

  defp sentinel(rest, ["0"], context, _line, _bytes) do
    {rest, [0], context}
  end

  defp struct_type(rest, args, context, _line, _bytes) do
    case Enum.reverse(args) do
      ["struct" | types] -> {rest, [{:struct, types}], context}
    end
  end

  # function post-traversals

  defp callconv(rest, [type, "callconv"], context, _line, _bytes) do
    {rest, [{:callconv, type}], context}
  end

  def parse(str) do
    case type(str) do
      {:ok, [result], "", _context, _line, _bytes} -> result
    end
  end

  defp errorlist(rest, errors, context, _line, _bytes) do
    {rest, [errors], context}
  end

  defp errorunion_only("!" <> _, _args, _context, _line, _bytes), do: {:error, "unreportable"}

  defp errorunion_only(rest, [errors, :error], context, _line, _bytes) do
    {rest, [{:errorunion, errors}], context}
  end

  defp function_call_type(rest, args, context, _line, _bytes) do
    [call | args] = Enum.reverse(args)
    {rest, [{:comptime_call, call, args}], context}
  end

  defp builtinfunction(rest, [name, :function], context, _line, _bytes) do
    {rest, [{:function, name}], context}
  end

  defp comptime_call_type(rest, [args | callname], context, _line, _bytes) do
    {rest, [{:comptime_call, Enum.reverse(callname), args}], context}
  end

  defp comptime_call_params(rest, args, context, _line, _bytes) do
    {rest, [Enum.reverse(args)], context}
  end
end
